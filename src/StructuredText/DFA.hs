module StructuredText.DFA
      ( DFA (..)
      , LDFA
      , toDFA
      , accept, transition
      , monitors
      ) where

import qualified Data.Set as S
import Data.Set (Set, (\\))
import qualified Data.Map.Strict as M
import Data.Map.Strict (Map)
import Data.Maybe (fromMaybe)
import Data.List (foldl')
import Control.Arrow ((&&&), (***), first)
import Control.Monad (join)
import StructuredText.LTL (AtomicProp (..))
import StructuredText.ABA (ABA (..))
import StructuredText.Boolean (dnfFalse, dnfTrue, satisfies)

-- import Debug.Trace (trace)
trace :: String -> a -> a
trace _ = id

type LDFA a = DFA (Set a)

-- | DFA with states represented as indexes generated by enumerating the DNFs appearing in the ABA'.
data DFA a = DFA
      { statesDFA :: !Int
      , alphaDFA  :: !(Set a)
      , currDFA   :: !Int
      , finalDFA  :: !(Set Int)
      , deltaDFA  :: !(Map (Int, a) Int)
      }

toDFA :: (Ord s, Ord a, AtomicProp s) => ABA s a -> DFA a
toDFA aba = DFA
      { statesDFA = S.size allStates
      , alphaDFA  = alphaABA aba
      , currDFA   = toTag $ currABA aba
      , finalDFA  = S.map toTag $ S.filter (finalABA aba `satisfies`) allStates
      , deltaDFA  = M.fromAscList $ map (first toTag *** toTag) $ M.toAscList mapify
      }
      where -- mapify :: (B s -> a -> B s) -> Map (B s, a) (B s)
            mapify = M.fromAscList $ S.toAscList (S.map (id &&& uncurry deltaP) allCases)

            -- allCases :: Set (B s, a)
            allCases = S.cartesianProduct allStates (alphaABA aba)

            -- allStates :: Set (B s)
            allStates = S.fromList [dnfTrue, dnfFalse] `S.union` iter2 deltaP (S.singleton $ currABA aba) (alphaABA aba)

            -- | s U (map f (s x bs)) U (map f (map f (s x bs))) U ... until fixed point reached.
            iter2 :: Ord a => (a -> b -> a) -> Set a -> Set b -> Set a
            iter2 f s bs = iter2' f s ss bs
                  where ss = S.map (uncurry f) (S.cartesianProduct s bs) \\ s

            iter2' :: Ord a => (a -> b -> a) -> Set a -> Set a -> Set b -> Set a
            iter2' f s ss bs = trace (show (S.size s) ++ ": " ++ show (S.size ss) ++ " x " ++ show (S.size bs))
                        $ if S.size ss == 0 then s else iter2' f s' ss' bs
                  where s'  = s `S.union` ss
                        ss' = S.map (uncurry f) (S.cartesianProduct ss bs) \\ s'

            -- | Map the transition function onto the terms in the boolean expression and reduce.
            -- deltaP :: B s -> a -> B s
            deltaP s = join . (deltaABA aba <$> s <*>) . pure

            toTag = fromMaybe (-1) . flip S.lookupIndex allStates

transition :: Ord a => DFA a -> a -> DFA a
transition dfa a = dfa { currDFA = M.findWithDefault 0 (currDFA dfa, a) (deltaDFA dfa) }

-- | For finite [a].
accept :: Ord a => DFA a -> [a] -> Bool
accept dfa m = S.member (currDFA dfa') $ finalDFA dfa'
      where dfa' = foldl' transition dfa m

-- | Returns false iff DFA ends in bottom.
monitors :: Ord a => DFA a -> [a] -> Bool
monitors dfa m = currDFA dfa' /= 0
      where dfa' = foldl' transition dfa m

