{-# LANGUAGE RankNTypes #-}
module StructuredText.ABA
      ( ABA (..)
      -- , acceptABA
      , deltaP
      -- , formulaRun, acceptABAwithRun
      -- , aba1
      , set1, set2, set3, bs1, bs2, bs3, bs4, bs5, bs6
      ) where

import Prelude hiding (concat)
import qualified Data.Set as S
import Data.Set (Set)
import qualified Data.Map.Strict as M
import Data.Map.Strict (Map)
import StructuredText.LTL (AtomicProp (..))
import StructuredText.Boolean (B (..))

data ABA state alph = ABA
      { statesABA :: !(Set state)
      , alphaABA  :: !(Set alph)
      , currABA   :: !(B state) -- BTerm s
      , finalABA  :: !(Set state)
      , deltaABA  :: state -> alph -> B state
      }

--Expand Map (s, a) (B s) to (B s -> a -> B s)
deltaP :: (AtomicProp s, Eq s, Ord s, Ord a) => Map (s, a) (B s) -> B s -> a -> B s
deltaP delta t a = case t of
     BTrue -> BTrue
     BFalse -> BFalse
     BTerm s -> M.findWithDefault BTrue (s, a) delta
     BAnd b1 b2 -> BAnd (deltaP delta b1 a) (deltaP delta b2 a)
     BOr b1 b2 -> BOr (deltaP delta b1 a) (deltaP delta b2 a)

--does the ABA aut accept the input word?
--if boolean expression BTrue, accept; if BFalse; reject; else continue run
-- acceptABA :: (AtomicProp s, Ord s, Ord a) => ABA s a -> [a] -> Bool
-- acceptABA aut (a : as) = case next_state of
--      BTrue     -> True
--      BFalse    -> False
--      _         -> acceptABA aut {currABA = next_state} as
--      where next_state = simplify (deltaP (deltaABA aut) (currABA aut) a)
-- acceptABA aut [] = satisfied (currABA aut) (finalABA aut)

--what is thesequence of B s expressions generated by running word through an ABA aut?
-- formulaRun :: (AtomicProp s, Ord s, Ord a) => ABA s a -> [a] -> [B s]
-- formulaRun aut word = case word of
--      (a : as) -> simplify(currABA aut): formulaRun aut{currABA = deltaP (deltaABA aut) (currABA aut) a} as
--      []       -> [simplify (currABA aut)]

--is word accepted by automata? what is its formula-run?
--uses formulaRun so entire run is generated
-- acceptABAwithRun :: (AtomicProp s, Ord s, Ord a) => ABA s a -> [a] -> (Bool, [B s])
-- acceptABAwithRun aut word = (satisfied (Data.List.last run) (finalABA aut), run)
--      where run = formulaRun aut word

--for testing


-- aba1 :: ABA Char Integer
-- aba1 = ABA{statesABA = S.fromList['r','s','t'], currABA = BTerm 's', finalABA = S.fromList['t'], deltaABA = tran}
--       where tran :: Map (Char, Integer) (B Char)
--             tran =  M.fromList[(('r', 0), BOr (BAnd (BTerm 'r') (BTerm 's')) (BTerm 't')), (('r', 1), BOr (BTerm 'r') (BTerm 's')), (('s', 0), BAnd (BTerm 's') (BTerm 't')), (('s', 1), BTrue), (('t', 0), BFalse), (('t', 1), BTerm 'r')]

set1 :: Set Char
set1 = S.fromList ['r', 's', 't']

set2 :: Set Char
set2 = S.fromList ['r', 's', 't', 'u']

set3 :: Set Char
set3 = S.fromList ['s', 't', 'u']

bs1 :: B Char
bs1 = BAnd (BTerm 'r') (BOr (BTerm 's') (BTerm 't'))

bs2 :: B Char
bs2 = BOr BTrue (BTerm 'r')

bs3 :: B Char
bs3 = BAnd BFalse (BTerm 'r')

bs4 :: B Char
bs4 = BOr (BTerm 'a') (BTerm 'b')

bs5 :: B Char
bs5 = BAnd (BTerm 'x') (BTerm 'y')

bs6 :: B Char
bs6 = BOr bs2 bs3

