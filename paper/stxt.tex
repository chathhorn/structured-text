% \begin{abstract}
% 
% \end{abstract}

\section{Intro}

\paragraph{Stuff.}

Programmable logic controllers (PLCs) are used for industrial automation in many
safety- and security-critical contexts. The IEC 61131-3 standard informally
describes five languages intended for programming PLCs, one of which is
Structured Text (ST). As the scale and complexity of industrial automation grows, so
do the scale and complexity of these programs.

We present a system for runtime verification of PLC programs written in the
Structured Text language.

We implement our runtime verification system in Haskell.

The context: this project is part of a larger project to develop a ``virutal''
automation controller. Part of that project included an implementation of the
IEC 61131-3 Structured Text programming language, which we describe here along
with our extension to enable built-in runtime verification of Structured Text
programs.

The high-level design of our runtime verification system follows previous work
on runtime verification of linear temporal logic (LTL)
properties~\cite{bauer:rv_ltl}. Authors of Structured Text programs include a
specification of the program in comments. The specification is a set of LTL
propositions that refer to global symbols from the program source. Our
interpreter, then, translates the LTL specification to a B\"uchi automaton which
is interpreted along with the Sructured Text program.

LTL specifications might appear immediately before or after Structured Text
function definitions and may refer to either symbols used in the function
signature or global symbols.

\begin{enumerate}
\item Parse the Structured Text source, split out the comments.
\item Parse the comments for the LTL specification $\phi$.
\item Translate $\phi$ into the B\"uchi automata $B_\phi$ and $B_{\lnot\phi}$.
\item Translate $B_\phi$ and $B_{\lnot\phi}$ into finite-state machine $M_\phi$
\item Minimize the finite-state machine $M_\phi$ into $M'_\phi$.
\item Interpret both $M'_\phi$ and the Structured Text program (or translate
both into Python).
\end{enumerate}

\section{Motivation}

\section{Structured Text}

\section{LTL}

``Pnueliâ€™s LTL~\cite{pnueli:ltl} is a well-accepted lineartime temporal logic
used for specifying properties of infinite traces. In runtime verification, our
goal is to check LTL properties given finite prefixes of infinite
traces''~\cite{bauer:rv_ltl}.

\section{B\"uchi automata construction}

\section{Runtime verification of programs}

\section{Previous work on high-assurance PLC programming}

\subsection{High-assurance programming}

\subsection{Formal semantics for PLC programming languages}

In order to directly reason about PLC programs, we need to know what they mean
in some rigorous way. Programming language semantics typicaly fall into three
camps: denotational, operational, or axiomatic~\cite{hoare:axiomatic}. Each of
these approaches can be understood as a translation from statements in the
programming language to its ``meaning'' in terms of some mathematical or logical
structure. The approaches differ in what that ``meaning'' actually is: algebraic
objects or domains (denotational semantics), operations on an abstract machine
(operational), or assertions about how the program state evolves (axiomatic).

Previous work on the semantics of PLC languages includes:

\begin{itemize}

\item Coq semantics: Biha and Blech~\cite{biha:plc_sem1, biha:plc_sem2,
biha:plc_sem3}. They give a formal semantics for IL and sequential function
charts (SFC) and a tool for automatically generating SFC representations from a
graphical description. Also they prove safety properties of a PLC in a real
industrial demonstrator.

% Note: should look into this. The ``industrial demonstrator'' might be useful.
% The Coq semantics might be interesting. I'm curious how they formalized SFC as
% well as what the hell this tool is.

\item Petri net semantics: Heiner and Menzel~\cite{heiner:petri}. They give a
semantics for the IL language.

\item Sequential function charts~\cite{bauer:unifying}: ``SFCs lack an
unambiguous, complete semantic description. We point out a number of problems
and explain how these lead to different interpretations in commercial
programming environments.'' They present a pen-and-paper denotational semantics
of SFCs.

% Note: Petri nets, ugh.

\item $\mathbb{K}$ framework operational semantics: Huang et
al.~\cite{huang:kst}. They give an operational semantics of the Structured Text
language in the $\mathbb{K}$ framework. They use the framework to extract a
simple interpreter and model checker.

% Note: they cite me. :)

\end{itemize}

\subsection{Symbolic execution, testing}

\begin{itemize}

\item Concolic test generation: Bohlender et al.~\cite{bohlender:concolic}.

\end{itemize}

\subsection{Monitoring}

Also runtime verification.

\begin{itemize}

\item IDS: Had\u ziosmanovi\'c and Sommer. They appear to take advantage of the
generally highly-regular and predictable nature of many industrial control
systems while monitoring for anomalies. They apparently test their approach on a
water treatment plant.

% Note: maybe a broader scope, but it might be fruitful to think of the whole
% industrial process in which the PLC resides as the system to be verified.

\item LTL for RV: Bauer et al~\cite{bauer:rv_ltl}. They describe the tranformation from LTL
to B\"uchi automata for runtime monitoring (as opposed to model checking).

\item LTL to B\"uchi: Vardi~\cite{vardi:ltl_at}.

\end{itemize}

